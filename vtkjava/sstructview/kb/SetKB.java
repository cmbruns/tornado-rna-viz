package sstructview.kb;import java.util.*;import java.lang.*;public class SetKB extends Object {/* 	Simple Frame Representation System that supports classes and instances, 	and parent-child relationships, including multiple inheritance. 	*/	Hashtable	NameToObject = new Hashtable();	// all objects	Hashtable	ObjectToName = new Hashtable();	Hashtable	SetsToMembers = new Hashtable(); // hashTable of Vectors	Hashtable	MemberToSets = new Hashtable(); // hashTable of Vectors	Hashtable	TypeToInstances = new Hashtable();	Hashtable	InstanceToType = new Hashtable();	protected void addRelation(Hashtable relationTable, Object hashCode, Object obj) {		Vector items = (Vector)relationTable.get(hashCode);		if (items == null) {			items = new Vector(1);			relationTable.put(hashCode, items);		}		items.addElement(obj);	}	protected Object get1Value(Hashtable relationTable, Object hashCode) {		// shortcut routine for hashtables that store a single-valued vector		Vector items = (Vector)relationTable.get(hashCode);		if (items == null) {			return null;		} else {			return items.firstElement();		}	}		public Vector stringsToObjects(Vector names) {		if (names == null) {			return null;		} else {			Enumeration e = names.elements();			String name = null;			Vector objects = new Vector();			while (e.hasMoreElements()) {				name = (String)e.nextElement();				objects.addElement(getObject(name));			}			return objects;		}	}		public void addInstance(String name, String type, Object obj) {		NameToObject.put(name, obj);		ObjectToName.put(obj, name);		addRelation(TypeToInstances, type, name);		addRelation(InstanceToType, name, type);	}		public void addChild(String parent, String child) {		addRelation(SetsToMembers, parent, child);		addRelation(MemberToSets, child, parent);	}	/*		Accessor routines		Default is by String; can also be by object		*/		public Object getObject(String s) {		if (s == null) { 			return null;		}		Object o = NameToObject.get(s);		if (o == null) {			System.out.println("Couldn't get object named "+s);		}		return o;	}		public Vector getObjects(Vector vNames) {		if (vNames == null) {			return null;		} else {			Enumeration e = vNames.elements();			Vector vObjects = new Vector();			String s = null;			while (e.hasMoreElements()) {				s = (String)e.nextElement();				vObjects.addElement(getObject(s));			}			return vObjects;		}	}	public String getName(Object o) {		return (String)ObjectToName.get(o);	}	public String getType(String s) {		return (String)get1Value(InstanceToType,s);	}		/*		 	PARENTS AND ANCESTORS			A parent is the immediate ancestor of an object.		Objects can have several immediate parents (multiple inheritance).		Parents are typed.			*/		public Vector getParents(String child) {		if (child == null) {			return null;		} else {			return (Vector)MemberToSets.get(child);		}	}		public String getPrimaryParent(String child) {		if (child == null) {			return null;		} else {			return (String)get1Value(MemberToSets, child);		}	}		public String getParent(String child, String type) {		/*		returns parent of a particular type, or null if no such parent exists		*/		if (child == null) {			return null;		} else {			Vector parents = getParents(child);			Enumeration e = parents.elements();			String s = null;			while (e.hasMoreElements()) {				s = (String)e.nextElement();				if (type.equalsIgnoreCase(getType(s))) {					return s;				}			}			return null;		}	}		public String getAncestor(String child, String type) {		if (child == null) {			return null;		} else {			Vector parents = getAncestors(child);			Enumeration e = parents.elements();			String ancestorName = null;			String ancestorType = null;			while (e.hasMoreElements()) {				ancestorName = (String)e.nextElement();				ancestorType = getType(ancestorName);				if (type.equalsIgnoreCase(ancestorType)) {					return ancestorName;				}			}			return null;		}	}	/*			String immediateParent = (String)get1Value(MemberToSets, child);			if (immediateParent == null) {				return null;			} else {				String immediateParentType = (String)get1Value(InstanceToType, immediateParent);				if (immediateParentType.equalsIgnoreCase(type)) {					return immediateParent;				} else {					return getParent(immediateParent, type);				}			}*/	// alternate accessor methods		public Vector getParents(Object child) {		return getParents((String)ObjectToName.get(child));	}/*	public String getParent(Object child, String type) {		return getParent((String)ObjectToName.get(child), type);	}*/	protected void addElements(Vector main, Vector additions, boolean addNewOnly) throws java.lang.NullPointerException{		if (additions != null) {			if (main == null) {				throw new java.lang.NullPointerException("can't add elements to null vector");			}			Enumeration e = additions.elements();			Object o = null;			while (e.hasMoreElements()) {				o = e.nextElement();				if ((!addNewOnly) || (!main.contains(o))) {					main.addElement(o);				}			}		}		}		public Vector getAncestors(String child) {		if (child == null) {			return null;		} else {			Vector parents = getParents(child);			if (parents == null) {				return null;			} else {				Vector ancestors = new Vector();				Enumeration e = parents.elements();				String parent = null;				while (e.hasMoreElements()) {					parent = (String)e.nextElement();					if (!ancestors.contains(parent)) {						ancestors.addElement(parent);					}					addElements(ancestors, getAncestors(parent), true);				}				return ancestors;			}		}	}	public String getNextParent(String child, String currentParent) {		Vector groups = getAncestors(child);		if (groups != null) {			int i = groups.indexOf(currentParent);			if (i == -1) {				return ((String)groups.elementAt(0));			} else if (i+1 == groups.size()) {				return (child);			} else {				return ((String)groups.elementAt(i+1));			}		} else {			return null;		}	}		public Vector getChildren(String parent) {		if (parent == null) {			return null;		} else {			return (Vector)SetsToMembers.get(parent);		}	}		public Vector getLeaves(String parent, boolean returnObjects) {		if (parent == null) {			return null;		} else {			Vector kids = (Vector)SetsToMembers.get(parent);			if ((kids == null) || (kids.size() == 0)) {				return null;			} else {				Vector leafList = new Vector();				// has children; iterate and select the leaves				Enumeration e = kids.elements();				Object child = null;				while (e.hasMoreElements()) {					child = e.nextElement();					if (child instanceof String) {						Vector grandKids = getLeaves((String)child);						if (grandKids == null) {							if (returnObjects) {								leafList.addElement(getObject((String)child));							} else {								leafList.addElement(child);							}						} else {							Enumeration eGrandKids = grandKids.elements();							while (eGrandKids.hasMoreElements()) {								if (returnObjects) {									leafList.addElement(getObject((String)eGrandKids.nextElement()));								} else {									leafList.addElement(eGrandKids.nextElement());								}							}						}					} else {						System.out.println("getLeaves found a non-String object. :( ");					}				}				return leafList;			}		}	}	public Vector getLeaves(String parent) {		return getLeaves(parent, false);	}		/**	 * Returns all the descendents of the parent. 	 * @param	parent	root of the subtree; not included in search	 * @param	type	type of descendents to return	 *					if null, returns all descendents	 * @param	includeParent	if true, includes the parent in the returned	 *					vector (provided it matches the type restriction)     * @return vector of descendents that match the type.	 **/	public Vector getDescendents(String parent, String type, boolean includeParent) {		if (parent == null) {			return null;		} else {			Vector leafList = new Vector();			if (includeParent) {				if ((type == null) || (type.equalsIgnoreCase(getType(parent)))) {					leafList.addElement(parent);				}			}			Vector kids = (Vector)SetsToMembers.get(parent);			if ((kids != null) && (kids.size() > 0)) {				// has children; iterate and select the leaves				Enumeration e = kids.elements();				String child = null;				while (e.hasMoreElements()) {					child = (String)e.nextElement();					if ((type == null) || (type.equalsIgnoreCase(getType(child)))) {						leafList.addElement(child);					}					addElements(leafList, getDescendents(child, type, false), true);				}			}			if (leafList.size() == 0) {				return null;			} else {				return leafList;			}		}	}	/**	 * Returns all the descendents of each of the parents. Optionally includes	 * the parents in the search.	 * in the search 	 * @param	parent	root of the subtree; not included in search	 * @param	type	type of descendents to return	 *					if null, returns all descendents	 * @param	includeParents	if true, includes each of the parents in the returned	 *					vector (provided they match the type restriction)     * @return vector of descendents that match the type.	 **/	public Vector getDescendents(Vector parents, String type, boolean includeParents) {		Enumeration e = parents.elements();		Vector leaves = new Vector();		String parent = null;		while (e.hasMoreElements()) {			parent = (String)e.nextElement();			addElements(leaves, getDescendents(parent, type, includeParents), true);		}		if (leaves.size() == 0) {			return null;		} else {			return leaves;		}	}		public Vector getPrimarySiblings(String child) {		// returns a vector of strings		if (child == null) {			return null;		} else {			String parent = getPrimaryParent(child);			Vector siblings = getChildren(parent);			return siblings;		}	}		public Vector getSiblings(String child) {		// returns a vector of strings of children (no duplicates)		if (child == null) {			return null;		} else {			Vector parents = getParents(child);			if (parents == null) {				return null;			} else {				Vector siblings = new Vector();				Enumeration e = parents.elements();				String parent = null;				while (e.hasMoreElements()) {					parent = (String)e.nextElement();					addElements(siblings, getChildren(parent), true);				}				return siblings;			}		}	}		public Vector getSiblings(Object child) {		// returns a vector of Objects		Vector v = getSiblings((String)ObjectToName.get(child));		if (v == null) {			return null;		} else {			Enumeration e = v.elements();			Vector vObjects = new Vector();			String s = null;			while (e.hasMoreElements()) {				s = (String)e.nextElement();				vObjects.addElement(getObject(s));			}			return vObjects;		}	}		// Debugging routines	public void dump() {		System.out.println("======================================================");		System.out.println("NameToObject");		dumpHashtable(NameToObject);		System.out.println("======================================================");		System.out.println("ObjectToName");		dumpHashtable(ObjectToName);		System.out.println("======================================================");				System.out.println("SetsToMembers");		dumpHashtable(SetsToMembers);		System.out.println("======================================================");		System.out.println("MemberToSets");		dumpHashtable(MemberToSets);		System.out.println("======================================================");	}		public void dumpHashtable(Hashtable ht) {		Enumeration keys = null;		Object key = null;		Object data = null;		keys = ht.keys();		while (keys.hasMoreElements()) {			key = keys.nextElement();			data = ht.get(key);			if (data instanceof Vector) {				System.out.println("KEY "+key+" : VECTOR "+data.toString());				} else {				System.out.println("KEY "+key+" : "+data.toString());				}		}	}		public final static String vectorToStrings(Vector v, String sep) {		if (v == null) {			return "";		}		Enumeration e = v.elements();		String returnString = null;		while (e.hasMoreElements()) {			if (returnString == null) {				returnString = (String)e.nextElement();			} else {				returnString = returnString + sep + (String)e.nextElement();			}		}		return returnString;	}}