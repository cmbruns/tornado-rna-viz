package sstructview.kb;import java.applet.*;import java.io.*;import java.util.*;import java.awt.*;import java.net.*;public class TypedSelection extends Object {	static final int SUBSEQ_VALUES = 1; // strung together ACTGTCTGAT	static final int SUBSEQ_IDS = 2; // separated by spaces ## ## ### ## ##	static final int SUBSEQ_ENDPOINT_IDS = 3; // separated by a dash ##-##	static final int SINGLE_MODE = 0;	static final int MULTIPLE_MODE = 1;		private String selectionType = null;	private Vector selectedSets = null; // names of sets or objects	private int selectionMode = SINGLE_MODE;	private boolean automaticTypeSwitching = false;		private SetAndSequenceKB curKB = null;		//private SelectionRange selectedObjects = null;	public TypedSelection() {		selectedSets = new Vector();	}		public void setAutomaticTypeSwitching(boolean auto) {		automaticTypeSwitching = auto;	}		public boolean automaticTypeSwitching() {		return automaticTypeSwitching;	}		public String selectionType() {		return selectionType;	}	    /**     * Returns a list of selected objects     * @return the selected objects.     */	public Vector objects() {		if (size() == 0) {			return null;		} else {			return selectedSets;		}	}		public int size() {		return selectedSets.size();	}		public boolean isEmpty() {		return (selectedSets.size() == 0);	}		public void setSelectionType(String type) {		// check to see if existing selection is of this type; if not, clear selection		boolean foundTypeViolation = false;		Enumeration e = selectedSets.elements();		while (e.hasMoreElements()) {			if (!type.equalsIgnoreCase(curKB.getType((String)e.nextElement()))) {				foundTypeViolation = true;			}		}		if (foundTypeViolation) {			clearSelection();		}		selectionType = type;	}	private boolean legalObject(String name) {		if (selectionType() == null) {			return false;		} else {			return selectionType().equalsIgnoreCase(curKB.getType(name));		}	}		private boolean setTypeFromObject(String object) {		// check to see if existing selection is of this type; if not, clear selection		if (automaticTypeSwitching()) {			setSelectionType(curKB.getType(object));			return true;		} else {			return (legalObject(object));		}	}	public void setKB(SetAndSequenceKB newKB) {		curKB = newKB;	}	/** * *		¥	MANIPULATING SELECTION ELEMENTS * **/  	/**	 * Selects the object. All other objects are deselected.	 * @param selectionName	the object name	 **/	public void setSelectionTo(String selectionName) {		clearSelection();		addToSelection(selectionName);	}		/**	 * Adds object from selection.	 * @param selectionName	the object name	 **/	public void addToSelection(String selectionName) {		if (selectionName != null) {			Object obj = curKB.getObject(selectionName);			if (setTypeFromObject(selectionName)) {				selectedSets.addElement(selectionName);			}		}	}		/**	 * Removes object from selection.	 * @param selectionName	the object name	 **/	public void removeFromSelection(String selectionName) {		selectedSets.removeElement(selectionName);	}		/**	 * If item is already in selection, removes it, else adds it.	 * @param selectionName	the object name	 **/	public void toggleInSelection(String selectionName) {		if (selectedSets.indexOf(selectionName) >= 0) {			removeFromSelection(selectionName);		} else {			addToSelection(selectionName);		}	}		/**	 * Sets the selection to a range of objects in the kb sequence.	 * @param anchor	the object at the start of the range	 * @param extension	the object at the end of the range	 **/	public void selectRange(String anchor, String extension) {		if (setTypeFromObject(anchor)) {			selectedSets.removeAllElements();			Vector range = curKB.getRange(anchor, extension);			Enumeration e = range.elements();			while (e.hasMoreElements()) {				selectedSets.addElement(e.nextElement());			}		}	}	/**	 * Removes all objects from the selection so that no objects are selected.	 **/	public void clearSelection() {		selectedSets.removeAllElements();	}		/**	 * Returns a vector of selected leaf objects from the vector of selected sets	 **/	private Vector getSelectionObjects() {		Enumeration e = selectedSets.elements();		Vector children = null;		Vector selectedObjects = null;		while (e.hasMoreElements()) {			children = curKB.getLeaves((String)e.nextElement(), true);			curKB.addElements(selectedObjects, children, true);		}		return selectedObjects;	}		public String toString(String sep) {		return sstructview.kb.SetKB.vectorToStrings(selectedSets, sep);	}	public String toString() {		return toString(",");	}}