/**
 * str_annotationType.java
 *
 * This file was generated by XMLSpy 2006r3 Enterprise Edition.
 *
 * YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
 * OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
 *
 * Refer to the XMLSpy Documentation for further details.
 * http://www.altova.com/xmlspy
 */


package com.rnaml;

import com.altova.types.*;

public class str_annotationType extends com.altova.xml.Node {

	public str_annotationType(str_annotationType node) {
		super(node);
	}

	public str_annotationType(org.w3c.dom.Node node) {
		super(node);
	}

	public str_annotationType(org.w3c.dom.Document doc) {
		super(doc);
	}

	public str_annotationType(com.altova.xml.Document doc, String namespaceURI, String prefix, String name) {
		super(doc, namespaceURI, prefix, name);
	}
	
	public void adjustPrefix() {
		for (	org.w3c.dom.Node tmpNode = getDomFirstChild( Attribute, null, "comment" );
				tmpNode != null;
				tmpNode = getDomNextChild( Attribute, null, "comment", tmpNode )
			) {
			internalAdjustPrefix(tmpNode, false);
		}
		for (	org.w3c.dom.Node tmpNode = getDomFirstChild( Attribute, null, "reference-ids" );
				tmpNode != null;
				tmpNode = getDomNextChild( Attribute, null, "reference-ids", tmpNode )
			) {
			internalAdjustPrefix(tmpNode, false);
		}
		for (	org.w3c.dom.Node tmpNode = getDomFirstChild( Attribute, null, "analysis-ids" );
				tmpNode != null;
				tmpNode = getDomNextChild( Attribute, null, "analysis-ids", tmpNode )
			) {
			internalAdjustPrefix(tmpNode, false);
		}
		for (	org.w3c.dom.Node tmpNode = getDomFirstChild( Attribute, null, "database-ids" );
				tmpNode != null;
				tmpNode = getDomNextChild( Attribute, null, "database-ids", tmpNode )
			) {
			internalAdjustPrefix(tmpNode, false);
		}
		for (	org.w3c.dom.Node tmpNode = getDomFirstChild( Element, null, "base-conformation" );
				tmpNode != null;
				tmpNode = getDomNextChild( Element, null, "base-conformation", tmpNode )
			) {
			internalAdjustPrefix(tmpNode, false);
			new base_conformationType(tmpNode).adjustPrefix();
		}
		for (	org.w3c.dom.Node tmpNode = getDomFirstChild( Element, null, "base-pair" );
				tmpNode != null;
				tmpNode = getDomNextChild( Element, null, "base-pair", tmpNode )
			) {
			internalAdjustPrefix(tmpNode, false);
			new base_pairType(tmpNode).adjustPrefix();
		}
		for (	org.w3c.dom.Node tmpNode = getDomFirstChild( Element, null, "base-triple" );
				tmpNode != null;
				tmpNode = getDomNextChild( Element, null, "base-triple", tmpNode )
			) {
			internalAdjustPrefix(tmpNode, false);
			new base_tripleType(tmpNode).adjustPrefix();
		}
		for (	org.w3c.dom.Node tmpNode = getDomFirstChild( Element, null, "base-stack" );
				tmpNode != null;
				tmpNode = getDomNextChild( Element, null, "base-stack", tmpNode )
			) {
			internalAdjustPrefix(tmpNode, false);
			new base_stackType(tmpNode).adjustPrefix();
		}
		for (	org.w3c.dom.Node tmpNode = getDomFirstChild( Element, null, "helix" );
				tmpNode != null;
				tmpNode = getDomNextChild( Element, null, "helix", tmpNode )
			) {
			internalAdjustPrefix(tmpNode, false);
			new helixType(tmpNode).adjustPrefix();
		}
		for (	org.w3c.dom.Node tmpNode = getDomFirstChild( Element, null, "pseudoknot" );
				tmpNode != null;
				tmpNode = getDomNextChild( Element, null, "pseudoknot", tmpNode )
			) {
			internalAdjustPrefix(tmpNode, false);
			new pseudoknotType(tmpNode).adjustPrefix();
		}
		for (	org.w3c.dom.Node tmpNode = getDomFirstChild( Element, null, "single-strand" );
				tmpNode != null;
				tmpNode = getDomNextChild( Element, null, "single-strand", tmpNode )
			) {
			internalAdjustPrefix(tmpNode, false);
			new single_strandType(tmpNode).adjustPrefix();
		}
		for (	org.w3c.dom.Node tmpNode = getDomFirstChild( Element, null, "distance-constraint" );
				tmpNode != null;
				tmpNode = getDomNextChild( Element, null, "distance-constraint", tmpNode )
			) {
			internalAdjustPrefix(tmpNode, false);
			new distance_constraintType(tmpNode).adjustPrefix();
		}
		for (	org.w3c.dom.Node tmpNode = getDomFirstChild( Element, null, "surface-constraint" );
				tmpNode != null;
				tmpNode = getDomNextChild( Element, null, "surface-constraint", tmpNode )
			) {
			internalAdjustPrefix(tmpNode, false);
			new surface_constraintType(tmpNode).adjustPrefix();
		}
	}

	public static int getcommentMinCount() {
		return 0;
	}

	public static int getcommentMaxCount() {
		return 1;
	}

	public int getcommentCount() {
		return getDomChildCount(Attribute, null, "comment");
	}

	public boolean hascomment() {
		return hasDomChild(Attribute, null, "comment");
	}

	public SchemaString newcomment() {
		return new SchemaString();
	}

	public SchemaString getcommentAt(int index) throws Exception {
		return new SchemaString(getDomNodeValue(dereference(getDomChildAt(Attribute, null, "comment", index))));
	}

	public org.w3c.dom.Node getStartingcommentCursor() throws Exception {
		return getDomFirstChild(Attribute, null, "comment" );
	}

	public org.w3c.dom.Node getAdvancedcommentCursor( org.w3c.dom.Node curNode ) throws Exception {
		return getDomNextChild( Attribute, null, "comment", curNode );
	}

	public SchemaString getcommentValueAtCursor( org.w3c.dom.Node curNode ) throws Exception {
		if( curNode == null )
			throw new com.altova.xml.XmlException("Out of range");
		else
			return new SchemaString(getDomNodeValue( dereference(curNode) ) );
	}

	public SchemaString getcomment() throws Exception 
 {
		return getcommentAt(0);
	}

	public void removecommentAt(int index) {
		removeDomChildAt(Attribute, null, "comment", index);
	}

	public void removecomment() {
		while (hascomment())
			removecommentAt(0);
	}

	public void addcomment(SchemaString value) {
		if( value.isNull() == false )
		{
			appendDomChild(Attribute, null, "comment", value.toString());
		}
	}

	public void addcomment(String value) throws Exception {
		addcomment(new SchemaString(value));
	}

	public void insertcommentAt(SchemaString value, int index) {
		insertDomChildAt(Attribute, null, "comment", index, value.toString());
	}

	public void insertcommentAt(String value, int index) throws Exception {
		insertcommentAt(new SchemaString(value), index);
	}

	public void replacecommentAt(SchemaString value, int index) {
		replaceDomChildAt(Attribute, null, "comment", index, value.toString());
	}

	public void replacecommentAt(String value, int index) throws Exception {
		replacecommentAt(new SchemaString(value), index);
	}

	public static int getreference_idsMinCount() {
		return 0;
	}

	public static int getreference_idsMaxCount() {
		return 1;
	}

	public int getreference_idsCount() {
		return getDomChildCount(Attribute, null, "reference-ids");
	}

	public boolean hasreference_ids() {
		return hasDomChild(Attribute, null, "reference-ids");
	}

	public SchemaIDRef newreference_ids() {
		return new SchemaIDRef();
	}

	public SchemaIDRef getreference_idsAt(int index) throws Exception {
		return new SchemaIDRef(getDomNodeValue(dereference(getDomChildAt(Attribute, null, "reference-ids", index))));
	}

	public org.w3c.dom.Node getStartingreference_idsCursor() throws Exception {
		return getDomFirstChild(Attribute, null, "reference-ids" );
	}

	public org.w3c.dom.Node getAdvancedreference_idsCursor( org.w3c.dom.Node curNode ) throws Exception {
		return getDomNextChild( Attribute, null, "reference-ids", curNode );
	}

	public SchemaIDRef getreference_idsValueAtCursor( org.w3c.dom.Node curNode ) throws Exception {
		if( curNode == null )
			throw new com.altova.xml.XmlException("Out of range");
		else
			return new SchemaIDRef(getDomNodeValue( dereference(curNode) ) );
	}

	public SchemaIDRef getreference_ids() throws Exception 
 {
		return getreference_idsAt(0);
	}

	public void removereference_idsAt(int index) {
		removeDomChildAt(Attribute, null, "reference-ids", index);
	}

	public void removereference_ids() {
		while (hasreference_ids())
			removereference_idsAt(0);
	}

	public void addreference_ids(SchemaIDRef value) {
		if( value.isNull() == false )
		{
			appendDomChild(Attribute, null, "reference-ids", value.toString());
		}
	}

	public void addreference_ids(String value) throws Exception {
		addreference_ids(new SchemaIDRef(value));
	}

	public void insertreference_idsAt(SchemaIDRef value, int index) {
		insertDomChildAt(Attribute, null, "reference-ids", index, value.toString());
	}

	public void insertreference_idsAt(String value, int index) throws Exception {
		insertreference_idsAt(new SchemaIDRef(value), index);
	}

	public void replacereference_idsAt(SchemaIDRef value, int index) {
		replaceDomChildAt(Attribute, null, "reference-ids", index, value.toString());
	}

	public void replacereference_idsAt(String value, int index) throws Exception {
		replacereference_idsAt(new SchemaIDRef(value), index);
	}

	public static int getanalysis_idsMinCount() {
		return 0;
	}

	public static int getanalysis_idsMaxCount() {
		return 1;
	}

	public int getanalysis_idsCount() {
		return getDomChildCount(Attribute, null, "analysis-ids");
	}

	public boolean hasanalysis_ids() {
		return hasDomChild(Attribute, null, "analysis-ids");
	}

	public SchemaIDRef newanalysis_ids() {
		return new SchemaIDRef();
	}

	public SchemaIDRef getanalysis_idsAt(int index) throws Exception {
		return new SchemaIDRef(getDomNodeValue(dereference(getDomChildAt(Attribute, null, "analysis-ids", index))));
	}

	public org.w3c.dom.Node getStartinganalysis_idsCursor() throws Exception {
		return getDomFirstChild(Attribute, null, "analysis-ids" );
	}

	public org.w3c.dom.Node getAdvancedanalysis_idsCursor( org.w3c.dom.Node curNode ) throws Exception {
		return getDomNextChild( Attribute, null, "analysis-ids", curNode );
	}

	public SchemaIDRef getanalysis_idsValueAtCursor( org.w3c.dom.Node curNode ) throws Exception {
		if( curNode == null )
			throw new com.altova.xml.XmlException("Out of range");
		else
			return new SchemaIDRef(getDomNodeValue( dereference(curNode) ) );
	}

	public SchemaIDRef getanalysis_ids() throws Exception 
 {
		return getanalysis_idsAt(0);
	}

	public void removeanalysis_idsAt(int index) {
		removeDomChildAt(Attribute, null, "analysis-ids", index);
	}

	public void removeanalysis_ids() {
		while (hasanalysis_ids())
			removeanalysis_idsAt(0);
	}

	public void addanalysis_ids(SchemaIDRef value) {
		if( value.isNull() == false )
		{
			appendDomChild(Attribute, null, "analysis-ids", value.toString());
		}
	}

	public void addanalysis_ids(String value) throws Exception {
		addanalysis_ids(new SchemaIDRef(value));
	}

	public void insertanalysis_idsAt(SchemaIDRef value, int index) {
		insertDomChildAt(Attribute, null, "analysis-ids", index, value.toString());
	}

	public void insertanalysis_idsAt(String value, int index) throws Exception {
		insertanalysis_idsAt(new SchemaIDRef(value), index);
	}

	public void replaceanalysis_idsAt(SchemaIDRef value, int index) {
		replaceDomChildAt(Attribute, null, "analysis-ids", index, value.toString());
	}

	public void replaceanalysis_idsAt(String value, int index) throws Exception {
		replaceanalysis_idsAt(new SchemaIDRef(value), index);
	}

	public static int getdatabase_idsMinCount() {
		return 0;
	}

	public static int getdatabase_idsMaxCount() {
		return 1;
	}

	public int getdatabase_idsCount() {
		return getDomChildCount(Attribute, null, "database-ids");
	}

	public boolean hasdatabase_ids() {
		return hasDomChild(Attribute, null, "database-ids");
	}

	public SchemaIDRef newdatabase_ids() {
		return new SchemaIDRef();
	}

	public SchemaIDRef getdatabase_idsAt(int index) throws Exception {
		return new SchemaIDRef(getDomNodeValue(dereference(getDomChildAt(Attribute, null, "database-ids", index))));
	}

	public org.w3c.dom.Node getStartingdatabase_idsCursor() throws Exception {
		return getDomFirstChild(Attribute, null, "database-ids" );
	}

	public org.w3c.dom.Node getAdvanceddatabase_idsCursor( org.w3c.dom.Node curNode ) throws Exception {
		return getDomNextChild( Attribute, null, "database-ids", curNode );
	}

	public SchemaIDRef getdatabase_idsValueAtCursor( org.w3c.dom.Node curNode ) throws Exception {
		if( curNode == null )
			throw new com.altova.xml.XmlException("Out of range");
		else
			return new SchemaIDRef(getDomNodeValue( dereference(curNode) ) );
	}

	public SchemaIDRef getdatabase_ids() throws Exception 
 {
		return getdatabase_idsAt(0);
	}

	public void removedatabase_idsAt(int index) {
		removeDomChildAt(Attribute, null, "database-ids", index);
	}

	public void removedatabase_ids() {
		while (hasdatabase_ids())
			removedatabase_idsAt(0);
	}

	public void adddatabase_ids(SchemaIDRef value) {
		if( value.isNull() == false )
		{
			appendDomChild(Attribute, null, "database-ids", value.toString());
		}
	}

	public void adddatabase_ids(String value) throws Exception {
		adddatabase_ids(new SchemaIDRef(value));
	}

	public void insertdatabase_idsAt(SchemaIDRef value, int index) {
		insertDomChildAt(Attribute, null, "database-ids", index, value.toString());
	}

	public void insertdatabase_idsAt(String value, int index) throws Exception {
		insertdatabase_idsAt(new SchemaIDRef(value), index);
	}

	public void replacedatabase_idsAt(SchemaIDRef value, int index) {
		replaceDomChildAt(Attribute, null, "database-ids", index, value.toString());
	}

	public void replacedatabase_idsAt(String value, int index) throws Exception {
		replacedatabase_idsAt(new SchemaIDRef(value), index);
	}

	public static int getbase_conformationMinCount() {
		return 1;
	}

	public static int getbase_conformationMaxCount() {
		return 1;
	}

	public int getbase_conformationCount() {
		return getDomChildCount(Element, null, "base-conformation");
	}

	public boolean hasbase_conformation() {
		return hasDomChild(Element, null, "base-conformation");
	}

	public base_conformationType newbase_conformation() {
		return new base_conformationType(domNode.getOwnerDocument().createElementNS(null, "base-conformation"));
	}

	public base_conformationType getbase_conformationAt(int index) throws Exception {
		return new base_conformationType(dereference(getDomChildAt(Element, null, "base-conformation", index)));
	}

	public org.w3c.dom.Node getStartingbase_conformationCursor() throws Exception {
		return getDomFirstChild(Element, null, "base-conformation" );
	}

	public org.w3c.dom.Node getAdvancedbase_conformationCursor( org.w3c.dom.Node curNode ) throws Exception {
		return getDomNextChild( Element, null, "base-conformation", curNode );
	}

	public base_conformationType getbase_conformationValueAtCursor( org.w3c.dom.Node curNode ) throws Exception {
		if( curNode == null )
			throw new com.altova.xml.XmlException("Out of range");
		else
			return new base_conformationType( dereference(curNode) );
	}

	public base_conformationType getbase_conformation() throws Exception 
 {
		return getbase_conformationAt(0);
	}

	public void removebase_conformationAt(int index) {
		removeDomChildAt(Element, null, "base-conformation", index);
	}

	public void removebase_conformation() {
		while (hasbase_conformation())
			removebase_conformationAt(0);
	}

	public void addbase_conformation(base_conformationType value) {
		appendDomElement(null, "base-conformation", value);	
	}

	public void insertbase_conformationAt(base_conformationType value, int index) {
		insertDomElementAt(null, "base-conformation", index, value);
	}

	public void replacebase_conformationAt(base_conformationType value, int index) {
		replaceDomElementAt(null, "base-conformation", index, value);
	}

	public static int getbase_pairMinCount() {
		return 1;
	}

	public static int getbase_pairMaxCount() {
		return 1;
	}

	public int getbase_pairCount() {
		return getDomChildCount(Element, null, "base-pair");
	}

	public boolean hasbase_pair() {
		return hasDomChild(Element, null, "base-pair");
	}

	public base_pairType newbase_pair() {
		return new base_pairType(domNode.getOwnerDocument().createElementNS(null, "base-pair"));
	}

	public base_pairType getbase_pairAt(int index) throws Exception {
		return new base_pairType(dereference(getDomChildAt(Element, null, "base-pair", index)));
	}

	public org.w3c.dom.Node getStartingbase_pairCursor() throws Exception {
		return getDomFirstChild(Element, null, "base-pair" );
	}

	public org.w3c.dom.Node getAdvancedbase_pairCursor( org.w3c.dom.Node curNode ) throws Exception {
		return getDomNextChild( Element, null, "base-pair", curNode );
	}

	public base_pairType getbase_pairValueAtCursor( org.w3c.dom.Node curNode ) throws Exception {
		if( curNode == null )
			throw new com.altova.xml.XmlException("Out of range");
		else
			return new base_pairType( dereference(curNode) );
	}

	public base_pairType getbase_pair() throws Exception 
 {
		return getbase_pairAt(0);
	}

	public void removebase_pairAt(int index) {
		removeDomChildAt(Element, null, "base-pair", index);
	}

	public void removebase_pair() {
		while (hasbase_pair())
			removebase_pairAt(0);
	}

	public void addbase_pair(base_pairType value) {
		appendDomElement(null, "base-pair", value);	
	}

	public void insertbase_pairAt(base_pairType value, int index) {
		insertDomElementAt(null, "base-pair", index, value);
	}

	public void replacebase_pairAt(base_pairType value, int index) {
		replaceDomElementAt(null, "base-pair", index, value);
	}

	public static int getbase_tripleMinCount() {
		return 1;
	}

	public static int getbase_tripleMaxCount() {
		return 1;
	}

	public int getbase_tripleCount() {
		return getDomChildCount(Element, null, "base-triple");
	}

	public boolean hasbase_triple() {
		return hasDomChild(Element, null, "base-triple");
	}

	public base_tripleType newbase_triple() {
		return new base_tripleType(domNode.getOwnerDocument().createElementNS(null, "base-triple"));
	}

	public base_tripleType getbase_tripleAt(int index) throws Exception {
		return new base_tripleType(dereference(getDomChildAt(Element, null, "base-triple", index)));
	}

	public org.w3c.dom.Node getStartingbase_tripleCursor() throws Exception {
		return getDomFirstChild(Element, null, "base-triple" );
	}

	public org.w3c.dom.Node getAdvancedbase_tripleCursor( org.w3c.dom.Node curNode ) throws Exception {
		return getDomNextChild( Element, null, "base-triple", curNode );
	}

	public base_tripleType getbase_tripleValueAtCursor( org.w3c.dom.Node curNode ) throws Exception {
		if( curNode == null )
			throw new com.altova.xml.XmlException("Out of range");
		else
			return new base_tripleType( dereference(curNode) );
	}

	public base_tripleType getbase_triple() throws Exception 
 {
		return getbase_tripleAt(0);
	}

	public void removebase_tripleAt(int index) {
		removeDomChildAt(Element, null, "base-triple", index);
	}

	public void removebase_triple() {
		while (hasbase_triple())
			removebase_tripleAt(0);
	}

	public void addbase_triple(base_tripleType value) {
		appendDomElement(null, "base-triple", value);	
	}

	public void insertbase_tripleAt(base_tripleType value, int index) {
		insertDomElementAt(null, "base-triple", index, value);
	}

	public void replacebase_tripleAt(base_tripleType value, int index) {
		replaceDomElementAt(null, "base-triple", index, value);
	}

	public static int getbase_stackMinCount() {
		return 1;
	}

	public static int getbase_stackMaxCount() {
		return 1;
	}

	public int getbase_stackCount() {
		return getDomChildCount(Element, null, "base-stack");
	}

	public boolean hasbase_stack() {
		return hasDomChild(Element, null, "base-stack");
	}

	public base_stackType newbase_stack() {
		return new base_stackType(domNode.getOwnerDocument().createElementNS(null, "base-stack"));
	}

	public base_stackType getbase_stackAt(int index) throws Exception {
		return new base_stackType(dereference(getDomChildAt(Element, null, "base-stack", index)));
	}

	public org.w3c.dom.Node getStartingbase_stackCursor() throws Exception {
		return getDomFirstChild(Element, null, "base-stack" );
	}

	public org.w3c.dom.Node getAdvancedbase_stackCursor( org.w3c.dom.Node curNode ) throws Exception {
		return getDomNextChild( Element, null, "base-stack", curNode );
	}

	public base_stackType getbase_stackValueAtCursor( org.w3c.dom.Node curNode ) throws Exception {
		if( curNode == null )
			throw new com.altova.xml.XmlException("Out of range");
		else
			return new base_stackType( dereference(curNode) );
	}

	public base_stackType getbase_stack() throws Exception 
 {
		return getbase_stackAt(0);
	}

	public void removebase_stackAt(int index) {
		removeDomChildAt(Element, null, "base-stack", index);
	}

	public void removebase_stack() {
		while (hasbase_stack())
			removebase_stackAt(0);
	}

	public void addbase_stack(base_stackType value) {
		appendDomElement(null, "base-stack", value);	
	}

	public void insertbase_stackAt(base_stackType value, int index) {
		insertDomElementAt(null, "base-stack", index, value);
	}

	public void replacebase_stackAt(base_stackType value, int index) {
		replaceDomElementAt(null, "base-stack", index, value);
	}

	public static int gethelixMinCount() {
		return 1;
	}

	public static int gethelixMaxCount() {
		return 1;
	}

	public int gethelixCount() {
		return getDomChildCount(Element, null, "helix");
	}

	public boolean hashelix() {
		return hasDomChild(Element, null, "helix");
	}

	public helixType newhelix() {
		return new helixType(domNode.getOwnerDocument().createElementNS(null, "helix"));
	}

	public helixType gethelixAt(int index) throws Exception {
		return new helixType(dereference(getDomChildAt(Element, null, "helix", index)));
	}

	public org.w3c.dom.Node getStartinghelixCursor() throws Exception {
		return getDomFirstChild(Element, null, "helix" );
	}

	public org.w3c.dom.Node getAdvancedhelixCursor( org.w3c.dom.Node curNode ) throws Exception {
		return getDomNextChild( Element, null, "helix", curNode );
	}

	public helixType gethelixValueAtCursor( org.w3c.dom.Node curNode ) throws Exception {
		if( curNode == null )
			throw new com.altova.xml.XmlException("Out of range");
		else
			return new helixType( dereference(curNode) );
	}

	public helixType gethelix() throws Exception 
 {
		return gethelixAt(0);
	}

	public void removehelixAt(int index) {
		removeDomChildAt(Element, null, "helix", index);
	}

	public void removehelix() {
		while (hashelix())
			removehelixAt(0);
	}

	public void addhelix(helixType value) {
		appendDomElement(null, "helix", value);	
	}

	public void inserthelixAt(helixType value, int index) {
		insertDomElementAt(null, "helix", index, value);
	}

	public void replacehelixAt(helixType value, int index) {
		replaceDomElementAt(null, "helix", index, value);
	}

	public static int getpseudoknotMinCount() {
		return 1;
	}

	public static int getpseudoknotMaxCount() {
		return 1;
	}

	public int getpseudoknotCount() {
		return getDomChildCount(Element, null, "pseudoknot");
	}

	public boolean haspseudoknot() {
		return hasDomChild(Element, null, "pseudoknot");
	}

	public pseudoknotType newpseudoknot() {
		return new pseudoknotType(domNode.getOwnerDocument().createElementNS(null, "pseudoknot"));
	}

	public pseudoknotType getpseudoknotAt(int index) throws Exception {
		return new pseudoknotType(dereference(getDomChildAt(Element, null, "pseudoknot", index)));
	}

	public org.w3c.dom.Node getStartingpseudoknotCursor() throws Exception {
		return getDomFirstChild(Element, null, "pseudoknot" );
	}

	public org.w3c.dom.Node getAdvancedpseudoknotCursor( org.w3c.dom.Node curNode ) throws Exception {
		return getDomNextChild( Element, null, "pseudoknot", curNode );
	}

	public pseudoknotType getpseudoknotValueAtCursor( org.w3c.dom.Node curNode ) throws Exception {
		if( curNode == null )
			throw new com.altova.xml.XmlException("Out of range");
		else
			return new pseudoknotType( dereference(curNode) );
	}

	public pseudoknotType getpseudoknot() throws Exception 
 {
		return getpseudoknotAt(0);
	}

	public void removepseudoknotAt(int index) {
		removeDomChildAt(Element, null, "pseudoknot", index);
	}

	public void removepseudoknot() {
		while (haspseudoknot())
			removepseudoknotAt(0);
	}

	public void addpseudoknot(pseudoknotType value) {
		appendDomElement(null, "pseudoknot", value);	
	}

	public void insertpseudoknotAt(pseudoknotType value, int index) {
		insertDomElementAt(null, "pseudoknot", index, value);
	}

	public void replacepseudoknotAt(pseudoknotType value, int index) {
		replaceDomElementAt(null, "pseudoknot", index, value);
	}

	public static int getsingle_strandMinCount() {
		return 1;
	}

	public static int getsingle_strandMaxCount() {
		return 1;
	}

	public int getsingle_strandCount() {
		return getDomChildCount(Element, null, "single-strand");
	}

	public boolean hassingle_strand() {
		return hasDomChild(Element, null, "single-strand");
	}

	public single_strandType newsingle_strand() {
		return new single_strandType(domNode.getOwnerDocument().createElementNS(null, "single-strand"));
	}

	public single_strandType getsingle_strandAt(int index) throws Exception {
		return new single_strandType(dereference(getDomChildAt(Element, null, "single-strand", index)));
	}

	public org.w3c.dom.Node getStartingsingle_strandCursor() throws Exception {
		return getDomFirstChild(Element, null, "single-strand" );
	}

	public org.w3c.dom.Node getAdvancedsingle_strandCursor( org.w3c.dom.Node curNode ) throws Exception {
		return getDomNextChild( Element, null, "single-strand", curNode );
	}

	public single_strandType getsingle_strandValueAtCursor( org.w3c.dom.Node curNode ) throws Exception {
		if( curNode == null )
			throw new com.altova.xml.XmlException("Out of range");
		else
			return new single_strandType( dereference(curNode) );
	}

	public single_strandType getsingle_strand() throws Exception 
 {
		return getsingle_strandAt(0);
	}

	public void removesingle_strandAt(int index) {
		removeDomChildAt(Element, null, "single-strand", index);
	}

	public void removesingle_strand() {
		while (hassingle_strand())
			removesingle_strandAt(0);
	}

	public void addsingle_strand(single_strandType value) {
		appendDomElement(null, "single-strand", value);	
	}

	public void insertsingle_strandAt(single_strandType value, int index) {
		insertDomElementAt(null, "single-strand", index, value);
	}

	public void replacesingle_strandAt(single_strandType value, int index) {
		replaceDomElementAt(null, "single-strand", index, value);
	}

	public static int getdistance_constraintMinCount() {
		return 1;
	}

	public static int getdistance_constraintMaxCount() {
		return 1;
	}

	public int getdistance_constraintCount() {
		return getDomChildCount(Element, null, "distance-constraint");
	}

	public boolean hasdistance_constraint() {
		return hasDomChild(Element, null, "distance-constraint");
	}

	public distance_constraintType newdistance_constraint() {
		return new distance_constraintType(domNode.getOwnerDocument().createElementNS(null, "distance-constraint"));
	}

	public distance_constraintType getdistance_constraintAt(int index) throws Exception {
		return new distance_constraintType(dereference(getDomChildAt(Element, null, "distance-constraint", index)));
	}

	public org.w3c.dom.Node getStartingdistance_constraintCursor() throws Exception {
		return getDomFirstChild(Element, null, "distance-constraint" );
	}

	public org.w3c.dom.Node getAdvanceddistance_constraintCursor( org.w3c.dom.Node curNode ) throws Exception {
		return getDomNextChild( Element, null, "distance-constraint", curNode );
	}

	public distance_constraintType getdistance_constraintValueAtCursor( org.w3c.dom.Node curNode ) throws Exception {
		if( curNode == null )
			throw new com.altova.xml.XmlException("Out of range");
		else
			return new distance_constraintType( dereference(curNode) );
	}

	public distance_constraintType getdistance_constraint() throws Exception 
 {
		return getdistance_constraintAt(0);
	}

	public void removedistance_constraintAt(int index) {
		removeDomChildAt(Element, null, "distance-constraint", index);
	}

	public void removedistance_constraint() {
		while (hasdistance_constraint())
			removedistance_constraintAt(0);
	}

	public void adddistance_constraint(distance_constraintType value) {
		appendDomElement(null, "distance-constraint", value);	
	}

	public void insertdistance_constraintAt(distance_constraintType value, int index) {
		insertDomElementAt(null, "distance-constraint", index, value);
	}

	public void replacedistance_constraintAt(distance_constraintType value, int index) {
		replaceDomElementAt(null, "distance-constraint", index, value);
	}

	public static int getsurface_constraintMinCount() {
		return 1;
	}

	public static int getsurface_constraintMaxCount() {
		return 1;
	}

	public int getsurface_constraintCount() {
		return getDomChildCount(Element, null, "surface-constraint");
	}

	public boolean hassurface_constraint() {
		return hasDomChild(Element, null, "surface-constraint");
	}

	public surface_constraintType newsurface_constraint() {
		return new surface_constraintType(domNode.getOwnerDocument().createElementNS(null, "surface-constraint"));
	}

	public surface_constraintType getsurface_constraintAt(int index) throws Exception {
		return new surface_constraintType(dereference(getDomChildAt(Element, null, "surface-constraint", index)));
	}

	public org.w3c.dom.Node getStartingsurface_constraintCursor() throws Exception {
		return getDomFirstChild(Element, null, "surface-constraint" );
	}

	public org.w3c.dom.Node getAdvancedsurface_constraintCursor( org.w3c.dom.Node curNode ) throws Exception {
		return getDomNextChild( Element, null, "surface-constraint", curNode );
	}

	public surface_constraintType getsurface_constraintValueAtCursor( org.w3c.dom.Node curNode ) throws Exception {
		if( curNode == null )
			throw new com.altova.xml.XmlException("Out of range");
		else
			return new surface_constraintType( dereference(curNode) );
	}

	public surface_constraintType getsurface_constraint() throws Exception 
 {
		return getsurface_constraintAt(0);
	}

	public void removesurface_constraintAt(int index) {
		removeDomChildAt(Element, null, "surface-constraint", index);
	}

	public void removesurface_constraint() {
		while (hassurface_constraint())
			removesurface_constraintAt(0);
	}

	public void addsurface_constraint(surface_constraintType value) {
		appendDomElement(null, "surface-constraint", value);	
	}

	public void insertsurface_constraintAt(surface_constraintType value, int index) {
		insertDomElementAt(null, "surface-constraint", index, value);
	}

	public void replacesurface_constraintAt(surface_constraintType value, int index) {
		replaceDomElementAt(null, "surface-constraint", index, value);
	}

	private org.w3c.dom.Node dereference(org.w3c.dom.Node node) {
		return node;
	}
}
